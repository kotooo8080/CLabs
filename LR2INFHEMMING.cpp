// LR2INFHEMMING.cpp: определяет точку входа для консольного приложения.
//

#include "stdafx.h"
#include <cstdlib>
#include <stdio.h>
#include <bitset>
#include <cmath>  
#include <iostream>


using namespace std;

int main() {
	int u = 0;
	do {
		int s;                                      //переменная для записи исходного числа
		int k0 = 0, k1 = 0, k2 = 0, k3 = 0, k4 = 0;

		do {
			cout << "enter an integer, " << endl;
			cin >> s;                                //вводим неотрицательное десятичное число не превосходящее 2^19
		} while ((s < 0) || (s >= pow(2, 19)));


		bitset <19> y(s);  //вывод исходного числа на экран
		cout << y << endl;

		int d;
		d = (((s >> 0) & 1) << 0) | (((s >> 1) & 1) << 1) | (((s >> 2) & 1) << 2) | (((s >> 3) & 1) << 3) | (((s >> 4) & 1) << 5) |
			(((s >> 5) & 1) << 6) | (((s >> 6) & 1) << 7) | (((s >> 7) & 1) << 8) | (((s >> 8) & 1) << 9) | (((s >> 9) & 1) << 10) |
			(((s >> 10) & 1) << 11) | (((s >> 11) & 1) << 13) | (((s >> 12) & 1) << 14) | (((s >> 13) & 1) << 15) | (((s >> 14) & 1) << 17) |
			(((s >> 15) & 1) << 18) | (((s >> 16) & 1) << 19) | (((s >> 17) & 1) << 20) | (((s >> 18) & 1) << 21);
		cout << d << endl;    //вставляем в число дополнительные разряды 

		bitset<24> b(d);      //создаем bitset размером 24 бита, куда помещаем строку с дополнительными битами для вывода на экран
		cout << "number with bits  " << b << endl;


		int r0, r1, r2, r3, r4;   //записываем матрицу преобразования построчно

		r0 = 11184810;
		r1 = 6710886;
		r2 = 1973790;
		r3 = 130561;
		r4 = 511;

		int p = 0;
		for (p = 0; p <= 23; p++) {
			if ((((d >> p) & 1) & (r0 >> p) & 1) == 1)
				k0++;
			if ((((d >> p) & 1) & (r1 >> p) & 1) == 1)
				k1++;
			if ((((d >> p) & 1) & (r2 >> p) & 1) == 1)
				k2++;
			if ((((d >> p) & 1) & (r3 >> p) & 1) == 1)
				k3++;
			if ((((d >> p) & 1) & (r4 >> p) & 1) == 1)
				k4++;
		};
		cout << k0 << k1 << k2 << k3 << k4 << endl;

		k0 = (k0 % 2 == 0) ? 0 : 1;
		k1 = (k1 % 2 == 0) ? 0 : 1;
		k2 = (k2 % 2 == 0) ? 0 : 1;
		k3 = (k3 % 2 == 0) ? 0 : 1;
		k4 = (k4 % 2 == 0) ? 0 : 1;

		cout << k0 << k1 << k2 << k3 << k4 << endl;     //вывод контрольных битов
		int y0 = k0, y1 = k1, y2 = k2, y3 = k3, y4 = k4;

		d = d | (k0 << 23);
		d = d | (k1 << 22);
		d = d | (k2 << 20);
		d = d | (k3 << 16);
		d = d | (k4 << 8);

		cout << "d  " << bitset<24>(d) << endl;

		//decoder

		int v;
		do {
			cout << "enter erronious bit (1-24)" << endl;      //ввод пользователем номера ошибочного бита
			cin >> v;
		} while ((v < 1) || (v > 24));




		unsigned int mask = (1 << (24 - v));  //создаем маску для того, чтобы заменить бит на ошибочный
		unsigned int f = d ^= mask;
		bitset <24> h(f);
		cout << "24 bit number with erronious bit  " << h << endl;



		cout << bitset<24>(d) << endl;

		k0 = k1 = k2 = k3 = k4 = 0;
		p = 0;
		for (p = 0; p <= 23; p++) {
			((((f >> p) & 1) & (r0 >> p) & 1) == 1) ? k0++ : k0 = k0;
			((((f >> p) & 1) & (r1 >> p) & 1) == 1) ? k1++ : k1 = k1;
			((((f >> p) & 1) & (r2 >> p) & 1) == 1) ? k2++ : k2 = k2;
			((((f >> p) & 1) & (r3 >> p) & 1) == 1) ? k3++ : k3 = k3;
			((((f >> p) & 1) & (r4 >> p) & 1) == 1) ? k4++ : k4 = k4;
		};

		cout << "bits " << k0 << k1 << k2 << k3 << k4 << endl;
		int m0, m1, m2, m3, m4;
		m0 = m1 = m2 = m3 = m4 = 0;

		m0 = (k0 % 2 == 0) ? 0 : 1;
		m1 = (k1 % 2 == 0) ? 0 : 1;
		m2 = (k2 % 2 == 0) ? 0 : 1;
		m3 = (k3 % 2 == 0) ? 0 : 1;
		m4 = (k4 % 2 == 0) ? 0 : 1;

		cout << "bits2 " << m0 << m1 << m2 << m3 << m4 << endl; //вывод контрольных битов декодера


		int res = 0;

		res = m0 | (m1 << 1) | (m2 << 2) | (m3 << 3) | (m4 << 4);

		cout << "res " << res << endl;


		cout << "enter values again? yes - 1,no - 0 " << endl;
		cin >> u;
	} while (u == 1);

	system("pause");
	return 0;
}